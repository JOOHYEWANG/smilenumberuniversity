<template>
  <div class="page-container">
    <header class="main-menu">
      <nav>
        <ul>
          <li><a href="/">home</a></li>
          <li><a href="/Grid">math class</a></li>
          <li><a href="https://joohyewang9.wixsite.com/mathematics0">math lecture</a></li>
          <li><a href="https://joohyewang9.wixsite.com/mathematics0">math research</a></li>
        </ul>
      </nav>
    </header>

    <main class="main-content">
      <div class="math-article">
        <section class="section-block">
          <h1 class="title">SlidingPuzzle mathematics</h1>
          <p class="author left-align-text">
            <em class="italic-text">Hyewang Joo, Smile Number Institute</em>
          </p>
          <p class="address left-align-text">Hyewang Joo <br> Korea</p>
          <p class="email left-align-text">joohyewang@gmail.com</p>
          <p class="acknowledgement left-align-text">
            <small>This work was financially supported by KRF 2003-041-C20009</small>
          </p>
          <p class="keywords left-align-text">
            <small>Keywords: Sliding puzzle, P=NP, Information theory, Probability, Polynomial-time algorithm, Choice axiom</small>
          </p>

          <h2>Abstract</h2>
          <p class="left-align-text">
            우리는 비직관 알고리즘 위에서 퍼즐게임을 시작하기로 한다. 즉, 비-직관 알고리즘(<em class="italic-text">non-intuition algorithm</em>)을 슬라이딩 퍼즐에 적용한다. 그때 퍼즐은 스스로 완성된 형태(<em class="italic-text">1,2,3,...,n</em>)로 만들어진다. 우리는 이 논문에서 큰오기호(<em class="italic-text">big O notation</em>)를 사용하여서 <em class="italic-text">P=NP</em>를 만족한다는 것을 수치적 증명으로 보이지는 않는다. 우리는 슬라이딩 퍼즐게임을 최단거리로 풀이하는 문제가 <em class="italic-text">NP</em>라는 것을 알고 있으므로 실제로 슬라이딩 퍼즐게임에서 그것이 풀이되는 알고리즘을 제시하고 그것이 슬라이딩 퍼즐을 풀이되도록 만드는 것을 섀넌의 정보이론을 사용하여 증명한다. 그리고 정리 3.1의 증명이 수학적으로 불충분하다고 느낄수도 분들을 위하여 마지막 장에서 선택공리를 추가로 증명한다.
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>1. Introduction</h2>
          <p class="left-align-text">
            다음과 같이 가정하기로 한다.<sup>소개글 부분은 형식적인 약속 부분이므로 읽지 않고 넘어간다고 해도 무방하다.</sup> 경기자 2는 경기자 1의 모든 전략과 퍼즐게임에서의 승리 전략을 알고 있다. 이때 경기자 1은 자신의 첫번째 전략 선택 1을 따르지 않는다. 아래는 위의 특수한 상황에 대한 구체적인 설명이다. 경기자 1은 제한적인 조합적 계산능력을 가지고 있다. 퍼즐이 풀리는 조합계산의 길이를 $|N|$이라고 할때 그는 언제나 $|K|<|N|$의 계산길이 $|K|$를 가진다고 약속한다. 그러므로 경기자 1은 합리성을 구축하기 위하여, 즉 퍼즐게임의 풀이 방법을 알기 위하여 비-직관적 알고리즘을 사용한다. 그때 그는 2차원 슬라이딩 퍼즐에 관해서 그 풀이를 얻게된다. 이때 선택 1에 대한 비-직관 알고리즘을 적용한 결과를 선택 2라고 부르기로 한다. 아래는 풀리지 않은 숫자 슬라이딩 퍼즐과, 풀이된 슬라이딩 퍼즐을 보여준다.
          </p>

          <div class="table-container">
            <h3><em class="italic-text">Number Puzzle Game</em></h3>
            <table>
              <thead>
                <tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr>
              </thead>
              <tbody>
                <tr><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr>
                <tr><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr>
                <tr><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td></tr>
                <tr><td>21</td><td>22</td><td>23</td><td>24</td><td></td></tr>
              </tbody>
            </table>
          </div>

          <div class="table-container">
            <h3><em class="italic-text">Number Puzzle Game</em></h3>
            <table>
              <thead>
                <tr><th>19</th><th>6</th><th>11</th><th>16</th><th>21</th></tr>
              </thead>
              <tbody>
                <tr><td>2</td><td>7</td><td>12</td><td>17</td><td>22</td></tr>
                <tr><td>3</td><td>8</td><td></td><td>18</td><td>23</td></tr>
                <tr><td>4</td><td>9</td><td>14</td><td>1</td><td>24</td></tr>
                <tr><td>5</td><td>10</td><td>15</td><td>20</td><td>13</td></tr>
              </tbody>
            </table>
          </div>

          <p class="left-align-text">
            우리는 비직관 알고리즘을 적용한 결과 경기자 2에 대하여 합리성을 구축할수 있다.\\
            슬라이딩 퍼즐게임에서 자신의 처음 선택 1을 따르지 않는 선택 2를 비직관 알고리즘이라 부르기로 한다.\\
            지금 부터 경기자 2를 콤퓨터(인공지능)라고 가정하기로 한다. 콤퓨터는 게임에 대한 모든 승리전략과 경기자 1의 전략을 알고 있다고 가정한다. 그러나 그러한 콤퓨터의 전략에는 약간의 약점이 존재한다. 콤퓨터는 아주 빠른 번개같은 계산으로 경기자 1의 모든 전략을 알고 퍼즐 조합을 제시한다고 가정된다. 그때 경기자 1은 자신의 첫번째 선택 1을 따르지 않는 것으로 승리할수 있다는 다소 어이없는 전략을 사용한다. 왜냐하면 선택 1은 콤퓨터의 전략이기 때문이다. 그때 선택 1만을 제외한 다른 방향을 선택 하는 전략을 비-직관 알고리즘이라고 부르기로 하고 그것을 선택 2라고 나타내기로 한다. 이때 ``모든 전략을 아는데 왜? 비직관 알고리즘을 적용하는 것은 모르느냐?'' 그것은 슬라이딩 퍼즐의 다음 단계 (<em class="italic-text">stage</em>)에서 설명된다. 우리는 이러한 동일한 가정을 비직관 알고리즘을 적용한 다음 퍼즐의 단계에서 동일하게 적용할수 있다. 즉 콤퓨터는 이미 알고 그 조합으로 유도한 것이 된다. 그러나 매단계 시간의 흐름에 대하여 슬라이딩 퍼즐이 이미 풀이된 직후이다. 즉, 콤퓨터는 매단계 그의 전략을 수정해야 한다(콤퓨터가 과거를 바꿀수는 없다.)
          </p>

          <p class="left-align-text">
            다음으로 의사결정자의 계산능력을 정의하기로 한다. 선택 1은 그의 모든 계산 능력과 대응된다. 즉 그의 모든 계산의 결과로 선택 1을 채택하기 때문이다. 풀리지 않은 퍼즐이 주어져 있을때 의사결정자는 $T$번의 비-직관 알고리즘을 적용한다. 이때 $T$번의 적용 후 그에게는 퍼즐의 풀이되는 조합이 계산 되어지는 때가 존재한다. 이때 움직여야 하는 퍼즐 조합의 길이를 $|K|$라고 하자. 이때 우리는 의사결정자는 계산가능 영역에 도달했다고 이야기 하기로 한다. 이때 퍼즐이 풀리는 크기는 $|T|+|K|$라고 정의되고 의사결정자의 계산능력, 계산길이는 $|K|$라고 정의된다. 간단한 예를 들어보자. 충분히 큰 퍼즐조각을 가진 퍼즐 게임이 주어졌을때 의사결정자는 언제나 제한적인 계산능력 $|K|<|N|$을 가진다. 만약 $K=N-1$을 만족한다면 의사결정자는 그의 계산능력으로 $1/4$ (<em class="italic-text">UP, DOWN, LEFT, RIGHT</em>)의 퍼즐을 풀이할 수 있는 기회를 가진다는 것이다. 일반적으로 의사결정자의 계산능력이 $K=N-R$일때 그가 퍼즐을 풀이할 수 있는 확률적 가능성은 $(1/4)^R$이라고 정의된다. 일반적으로 경기자가 퍼즐위에서 계산가능 영역에 들어섰을때 조합 계산해내는 퍼즐조합은 최대크기를 가진다. 직관적으로는 당연해 보인다. 왜냐하면 계산 불 가능 영역에서 계산 가능 영역으로 들어서는 순간 그의 계산능력의 최대값이 계산 가능 영역이다.
          </p>

          <p class="left-align-text">
            이 논문에 소개되고 있는 무작위성 1, 2는 처음 슬라이딩 퍼즐을 게임이론의 공통지식을 대우로 적용하여 풀이되었을때 발견되었다. 처음 경기자 1이 자신의 계산능력으로 선택한 퍼즐의 방향을 선택 1이라 부르고 그것으로 부터 무작위성 1이 만들어 진다. 그리고 그에 대하여 자신의 선택 1을 제외한 선택을 선택 2라 부르고 그것으로 부터 무작위성 2가 만들어진다. 다음장 부터는 정보이론의 정보의 양 정의를 사용해서 이러한 무작위성의 발생이 결국은 슬라이딩 퍼즐을 풀이되도록 만들 것이라는 것을 증명할 것이다. 이러한 무작위성에 대한 수학적 엄밀한 정의는 <em class="italic-text">Appendix II</em>에 소개되고 있다.
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>2. Proof idea</h2>
          <p class="left-align-text">
            먼저 슬라이딩 퍼즐 위에서 확률공간을 정의해보자. 전체집합은 모든 퍼즐의 조합이고 그에 따라서 확률변수는 모든 길이의 조합이 발생할 확률이라고 둘수 있다. 그때 각각의 슬라이딩 퍼즐의 조합은 하나의 확률과 대응된다. 이때 그것을 확률공간이라고 부른다. 그럼 우리는 슬라이딩 퍼즐 공간이라는 것을 구축 하기로 한다. 충분히 큰 퍼즐이 주어졌을때 그러한 슬라이딩 퍼즐을 풀이하고 있는 의사결정자를 가정하자. 이때 의사결정자가 가지는 무작위 성 1의 정의에 의하여 그는 그의 계산능력을 넘어서는 퍼즐의 조합들과 자기 자신이 계산한 조합의 다름을 구분하지 못한다. 그러므로 충분히 큰 퍼즐에 대하여 그의 계산능력은 $0$이라고 정의하기로 하자. 그때 슬라이딩 퍼즐의 조합의 움직임은 무작위 적이다. 즉, 각각의 모든 슬라이딩 퍼즐의 조합들은 무작위적이라고 정의 하자. 그러므로 슬라이딩 퍼즐의 풀이 확률이 $0$부터 어떤 확률 값을 가질때 그것은 모두 무작위적이고 거짓값을 가진다고 가정하자.
          </p>

          <p class="left-align-text">
            퍼즐게임의 수학증명을 경제학 이론을 수학을 사용해서 증명한 것이 아닌 게임이론의 공통지식을 수학의 영역으로 가져온 경우라고 가정하자. 그때 '경제학 영역에서 수학의 명제식 증명을 자유롭게 할수 있는가?'는 더 이상 문제가 되지 않는다. 이때 게임이론에서는 사유, 추측을 할수 있는 생각하는 의사결정자를 가정해야 한다. 그런데 슬라이딩 퍼즐게임의 최단거리 결정문제는 이미 슬라이딩 퍼즐을 풀이하는 경기자를 가정한다. 그러므로 슬라이딩 퍼즐 위에서 게임이론의 공통지식을 수학으로 가지고 와서 수학증명식 방법으로 증명되었다고 하더라도 문제될 것이 없다고 생각한다. 이 논문은 그러한 증명을 소개하기로 한다. 특히 처음 슬라이딩 퍼즐게임 위에서 게임이론의 공통지식을 사용하여 발견한 비직관적 알고리즘, 선택 2는 그러한 게임에서 발생하는 무작위 특성을 사용하여 수학적으로 추상화 하였다. 그리고 그것을 수학적으로 정리 3.1에서 증명한다. 그러므로 이단락은 크게 별도로 그 수학적 오류나 비약에 대하여 신경쓸 부분은 없다고 생각한다. 그리고 그러한 무작위성의 정의의 약속에서 선택공리를 사용하였고 뒤에서 그것을 별도로 증명 한다.
          </p>

          <p class="left-align-text">
            슬라이딩 퍼즐게임의 논의공간은 슬라이딩 퍼즐이다. 이때 우리는 확률공간의 정의를 앞에서와 같이 생각했었다. 이때 의사결정자는 정의에 의하여 제한적인 계산능력을 가진다. 즉 그는 임의의 슬라이딩 퍼즐에 대하여 $(1/3)^R$의 그것을 풀이할수 있는 기회가 주어진다. 이때 충분히 큰 슬라이딩 퍼즐에 대하여 실제적으로 의사결정자의 계산능력은 매우 하찮기 때문에 그것을 $0$으로 간주해도 무방하다. 우리는 이때 슬라이딩 퍼즐 공간의 변수를 정보이론의 정보의 양인 확률의 역수의 로그값으로 정의한다. 그러면 그때 의사결정자의 계산능력에 대하여 모든 단계마다의 풀이 가능성에 따른 정보의 양이 정의된다. 이러한 정보의 양을 무작위 변수라고 부르기로 한다. 이러한 무작위 변수를 $r$이라고 나타내기로 하면 이러한 무작위 변수가 확률공간의 정의를 만족하는 것은 당연하다. 그리고 이러한 슬라이딩 퍼즐 공간을 $(\Omega, \mathscr{P}, r)$이라고 나타내기로 한다.<sup>그냥 확률공간으로 간주해도 된다.</sup>
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>3. Formal proof of the sliding puzzle space</h2>
          <p class="left-align-text">
            퍼즐게임에서는 첫번째 선택 1은 제한적인 계산 능력에 의하여 만들어진다. 만약 의사결정자가 이러한 선택을 한다면 그것은 충분히 큰 슬라이딩 퍼즐안에서 연속적으로 무작위성 1을 만들어 내는 것과 동일하다. 왜냐하면 직관적으로 무작위성이 만들어 지지 않는다면 그것은 그의 직관적인 계산대로 풀이 되어야 한다. 그런데 이때 중요한 것은 선택 2의 정의이다. 선택 1은 확률적으로 가장 높은 선택이다. 그런데 우리는 그것을 제외한 선택 2라는 것을 만들어내는 비직관적인 선택을 한다. 이것은 의사결정자 자신에게 예상하지 못한 결과를 만들어 낸다. 즉 그것은 누구도(의사결정자 자신을 포함한다.) 예측하지 못한 것이다. 예측하지 못했으므로 이곳에서 또한 무작위성 2가 만들어진다. 즉, 간단히 이야기 하자면 우리가 만들어내는 무작위성 1에서 탈출하는 방법은 또 다른 무작위성 2를 만들어 내는 것이다. 그리고 퍼즐이 풀이될 확률의 역수의 로그값인 정보이론의 정보의 양으로 소개글과 초록의 참값과 거짓값을 정의하기로 한다. 그리고 이러한 슬라이딩 퍼즐 공간을 $(\Omega, \mathscr{P}, r)$이라고 나타내기로 한다. 또한 아래의 정리 3.1이 성립한다. 아래 정리 3.1에 사용한 용어 무작위성 1, 2의 수학적 개념의 엄밀한 정의는 <em class="italic-text">Appendix II</em>에서 엄밀하게 약속하기로 한다.
          </p>

          <div class="theorem-block">
            <h3>Theorem</h3>
            <p class="left-align-text">
              슬라이딩퍼즐공간 $(\Omega, \mathscr{P}, r)$에서 무작위성 1에서 벗어나는 방법은 또 다른 무작위성 2를 발생 시키는 것이다.
            </p>
          </div>

          <div class="proof-block">
            <h3>Proof</h3>
            <p class="left-align-text">
              충분히 큰 슬라이딩퍼즐 위에서 최단거리 퍼즐조합을 찾는 문제는 의사결정자의 선택 1에 대하여 무작위적 패턴을 가진다고 정의된다. (왜냐하면 의사결정자의 계산능력을 $0$이라고 가정 가능하기 때문이다. 이때 퍼즐은 무작위적으로 만들어 진다고 약속 하자.) 그런데 또한 선택 1, 2는 서로 다르다. 우리는 최고로 높은 확률(의사결정자가 느끼는 가능성을 이야기한다.)로 만들어진 선택 1을 채택하지 않는다. 따라서 우리는 처음 예측할수 없었던 선택 2를 하게 되고, 즉 스스로에 대하여 무작위성 2가 발생한다. 선택 1은 퍼즐 위에서 스스로 무작위성을 만들어 낸다. 이때 무작위성이 만들어질때, 즉 퍼즐이 무작위적인 움직임으로 풀릴 가능성은 모든 퍼즐의 조합 가능수 $n$에 대하여 $1/n$으로 정의 가능하다. 그러므로 슬라이딩 퍼즐이 충분히 클때 그것의 정보(퍼즐이 풀이 가능한 조합)가 스스로에게 퍼즐로부터 정확히 전달될 확률은 $0$에 가깝다. 충분히 큰 슬라이딩 퍼즐에 대하여 임의의 퍼즐조각 움직임이 최단거리일 확률은 모든 퍼즐 조합의 가능한 수가 $n$이라할때 $1/n$이다.(슬라이딩 퍼즐의 모든 조합은 아주 크기 때문에 간단히 $0$에 가깝다고 표현 하였다.) 선택 1을 할때 정보의 양:=$\mathcal{I}(1)$, 선택 1을 제외한 선택을 할때 정보의 양:=$\mathcal{I}(1)^{c}$라고 정의 하기로 하자. 즉, 선택 2를 할때 선택 1을 하지 않는다. 퍼즐게임에서 의사결정자의 선택 2란 선택 1을 조합계산하고 그것을 고르지 않는다. 이때 선택된 조합의 정보양을 양($+$)의 기호를 사용한 조합이라고 나타내기로하면 임의의 단계 $S_i$에서의 의사결정자의 선택 2란 다음과 같은 정보의 양으로 정의된다. $S:=-\mathcal{I}(1)\cup +\mathcal{I}(1)^{c}$이 성립한다. 우리는 선택 1의 조합을 계산한다. 그것이 선택 1의 정보의 양이다. 그런데 선택 1은 발생하지 않는다. 그러므로 그것의 정보의 양은 사라져야 하기 때문에 뺄셈 해주어야 한다. 그것을 $S$에서 $-\mathcal{I}(1)$라고 작성 하기로 한다. 증명에서 선택 2의 정의는 선택 1을 사용하지 않는 방법으로 그 정보의 양을 뺄셈해주는 것이라고 약속 가능하다. 따라서 아래의 정의(1)이 성립한다.
            </p>
            <div class="math-display">
              $$S:=(\mathcal{I}(1)^{c} -\mathcal{I}(1))$$
            </div>

            <p class="left-align-text">
              슬라이딩퍼즐게임의 임의의 단계 $S_i$에서 전체 정보의 양은 정의 (1)에 의하여 다음과 같이 정의 가능 하다. 선택 1은 최단거리 찾기 게임에서 $1/n$이라는 확률을 가진다. 즉 모든 조합중 하나이므로 결정되지 않은 조합은 모든 슬라이딩 퍼즐의 조합이다. 그러므로 정보의 양은 1이라고 정의된다.<sup>정보이론의 정보의 양 정의에서 로그값을 사용하는 이유는 다음과 같다. 동전의 경우 밑을 $2$로 가지는 로그값을 사용한다. $k=\log_2 x$, 이와 같은 경우를 생각해보자. 로그함수를 사용하는 이유는 지수함수의 역함수를 표현하기 위해서 인데 지수함수는 $2^k$로 증가한다. 그것은 정보의 양의 정량화된 크기가 증가하는 것을 표현해낸다. 즉 로그값 $\log_2 x=k$은 몇번 증가 하였느냐를 표현한다. 그것은 정보의 양이다. 정량화된 정보의 양의 갯수를 의미하는게 로그를 사용하는 의미이다. 그러므로 로그함수의 역함수인 지수함수 $2^k$에서 $k$가 의미하는 것은 몇번의 불 확정적인 경우를 세는 것이다. 즉 이것은 로그함수에서 생각하면 불 확정적인 정보의 양의 갯수를 의미한다. 즉, 정보의 총 양이다. 그러므로 주사위에서는 <em class="italic-text">1,2,3,4,5,6</em>의 불 확정적인 정보를 가지므로 6을 밑으로하는 로그를 취해야한다. 그러므로 정보분할 표현에서는 각각의 정보분할의 <em class="italic-text">atom</em>갯수를 로그의 밑으로 가지면 충분하다.</sup> ``슬라이딩 퍼즐위에서 선택 1은 무작위적으로 퍼즐의 방향을 선택하는 것과 동일하다.'' 이러한 언급이 필요한 이유는 위에 사용한 $1/n$ 계산 때문이었다. 즉 임의로 퍼즐을 선택할때 의사결정자가 퍼즐을 풀이할 확률은 위와 같다. 그런데 `임의의 의사결정자가 충분히 큰 퍼즐을 풀이할때 최단거리 조합을 찾을 확률은 그에게 어떻게 적용될까?' 당연히 $1/n$이다. 이러한 문제에 대한 대답은 폴 에르되시 몬티홀 문제에 대한 대답으로 대신하기로 한다. ``어떻게 고정된 확률이 변한단 말인가?'' 이때 모든 경우 $\mathcal{I}(1) =\mathcal{I}(1)^{c} $이 성립한다. 왜냐하면 의사결정자가 선택 1을 하지 않는다고 하더라도 여전히 그의 계산능력은 동일하기 때문에 슬라이딩 퍼즐을 풀이할 확률은 변화하지 않는다. 이때 주의할 것은 선택 2의 정보의 양은 선택 1을 계산하여서 선택하고 그것을 제외한다. 즉, 선택 2는 계산에 의한 선택이 아니라는 것이다. 그럼 단순히 선택 1의 계산만을 한번 뺄셈해주면 그것이 표현된다. 왜냐하면 선택 2는 선택 1을 전제로 하기 때문이다. 즉, 한번 뺄셈해주면 선택 1의 계산을 사용하지 않고 그냥 선택하는 것이 된다. 그러므로 $S$를 계산하면 아래가 성립한다.
            </p>

            <div class="math-display">
              $$0=\log\frac{n}{n} = \log n - \log n = -\log \frac{1}{n} + \log \frac{1}{n} =\mathcal{I}(1) -\mathcal{I}(1)^{c}$$
            </div>

            <p class="left-align-text">
              이때 선택 2의 정보의 양이 $\mathcal{I}(1)^{c}$이라고 나타나지는 않는다. 왜냐하면 선택 1의 제외는 선택 1을 전제로하기 때문이다. 결론은 위의 로그계산에 의하여 퍼즐의 풀이 조합의 정보의 양, 즉 정보의 불확실한 정도는 존재하지 않는다.<sup>동전의 앞, 뒤 정보의양 정의를 생각해보자. 그것은 앞일수도 있고 뒤일수도 있는 경우가 사라진 것이다.</sup> 즉, 전체 정보의 양에서 선택 1의 정보양 만큼을 뺄셈해주면 그 역수인 확률이 발생하지 않는다. 선택 2는 언제나 선택 1을 전제로 하므로 확률적인 선택이 아닌 무작위적인 선택이 발생한다. 그러므로 선택 1의 정보의 양의 뺄셈은 의사결정자의 선택이 확률적 선택이 아니라는 것을 의미하므로 선택 2 또한 연속적으로 그렇게 정의된다.
            </p>

            <div class="math-display">
              $$|S|=\mathcal{I}(1)^{c} -\mathcal{I}(1)=0$$
            </div>

            <p class="left-align-text">
              따라서 슬라이딩 퍼즐게임에서 선택 2의 불 확실한 정보의양은 $0$이다. 즉, 다시말해서 그곳에는 확률적 선택이 존재하지 않는다.
            </p>
          </div>

          <h3>3.1 Randomness example & calculation of Theorem 3.1</h3>
          <p class="left-align-text">
            슬라이딩퍼즐게임의 정리 3.1에서는 정보이론의 정보의양 정의를 사용한 무작위성의 계산은 자명하므로 엄밀하게 언급하지 않고 짧게 주석에 아래와 같이 언급하였다. 임의의 로그에 대하여 증명 되었으므로 신경쓰지 않았다. 그러나 무작위성의 정의가 더욱 엄밀해야할 필요도 있고, 설명도 부족 할수 있겠다. 그러므로 이번장에는 구체적인 예제와 함께 조금 설명을 보충 하기로 한다.
          </p>

          <p class="left-align-text">
            ``정보이론의 정보의 양 정의에서 로그값을 사용하는 이유는 다음과 같다. 동전의 경우 밑을 $2$로 가지는 로그값을 사용한다. $k=\log_2 x$, 이와 같은 경우를 생각해보자. 로그함수를 사용하는 이유는 지수함수의 역함수를 표현하기 위해서 인데 지수함수는 $2^k$로 증가한다. 그것은 정보의 양의 정량화된 크기가 증가하는 것을 표현해낸다. 즉 로그값 $\log_2 x=k$은 몇번 증가 하였느냐를 표현한다. 그것은 정보의 양이다. 정량화된 정보의 양의 갯수를 의미하는게 로그를 사용하는 의미이다. 그러므로 로그함수의 역함수인 지수함수 $2^k$에서 $k$가 의미하는 것은 몇번의 불 확정적인 경우를 세는 것이다. 즉 이것은 로그함수에서 생각하면 불 확정적인 정보의 양의 갯수를 의미한다. 즉, 정보의 총 양이다. 그러므로 주사위에서는 <em class="italic-text">1,2,3,4,5,6</em>의 불 확정적인 정보를 가지므로 6을 밑으로하는 로그를 취해야한다. 그러므로 정보분할 표현에서는 각각의 정보분할의 <em class="italic-text">atom</em>갯수를 로그의 밑으로 가지면 충분하다.``
          </p>

          <p class="left-align-text">
            예제: $9$개의 퍼즐조각이 존재하는 슬라이딩 퍼즐을 생각하자. 그때 그것이 만들 수 있는 모든 조합은 ($9!=362880$)가지이다. 그러므로 그 중 최단거리는 임의로 주어지는 퍼즐조합에 대하여 *매단계 마다 그러한 $9!$가지의 퍼즐조합중 단 하나의 연역되는 조합의 경우라는 것은 자명하다. 그러므로 *임의의 퍼즐단계에 대하여 모든 조합은 $n=9!$가지이다. 그리고 매단계 최단 거리 조합은 $1/9!$이다. 그러므로 그것이 발생할 확률은 임의의 퍼즐조합이 주어졌을때 항상 매단계 $1/362880$의 확률을 가진다. 그럼 우리는 이때 $362880$의 로그밑을 잡으면 그때 그 무작위성 정보의 양은 $1$이라는 것을 알 수 있다.
          </p>

          <p class="left-align-text">
            위를 $9$퍼즐에 대하여 표현해보자. 즉, $9$가지 경우에 대하여 로그를 잡아야 한다. 즉, $\log_9 (1/9!)$가지는 그 중 무작위적인 경우가 발생하는 갯수이다. 그러므로 모든 $9$조각 슬라이딩 퍼즐의 매단계(<em class="italic-text">stage</em>)에
          </p>

          <div class="math-display">
            $$\log_{9}{362880} = 5.82636277244$$
          </div>
          <p class="left-align-text">
            의 무작위 성이 발생하고 이것이 바로 무작위성 1의 계산이다. 그러므로 매단계 $9$퍼즐이 최단거리로 풀이될 무작위성으로 표현된 확률은 모든 경우 아래와 같다.
          </p>

          <div class="math-display">
            $$\frac{1}{362880^{5.82636277244}}$$
          </div>

          <p class="left-align-text">
            로그의 밑 $362880$를 잡는 다는 의미는 그러한 경우가 매단계 무작위성의 양으로 발생하고 그것은 정보의 무작위성 양 계산에서는 $1$이다. 즉, 그것이 무작위성의 양의 하나이다.(주사위의 한면을 의미한다.) 그런데 앞의 계산에 의하여 매 단계마다 그러한 우연은 $5.82636277244$만큼 발생한다. 즉, 각각의 주사위 마다 그러한 경우가 가득차 있다고 생각하면 (9)의 지수계산은 이해에 편할 것이다. 즉, 무작위성 $5.82636277244$이 발생한다는 것은 $362880$이 동시에 그만큼 발생한다는 것이다.
          </p>

          <p class="left-align-text">
            따라서 $9$조각 슬라이딩 퍼즐을 풀이한다는 것은 우리가 퍼즐의 매 단계마다 거의 육면 주사위를 던지는 정도($5.82636277244$)의 우연(확률적인 무작위적인 경우)이 발생한다는 것을 알 수 있다. 즉, 매단계 육면 주사위를 던져서 그 방향을 결정하는 것과 거의 동치이다. 그러므로 랜덤랜덤 정리의 증명은 그러한 무작위적인 확률의 경우가 $0$이라는 것을 의미한다. 즉, 확률적 무작위성이 발생하지 않으므로 슬라이딩 퍼즐은 풀이된다. 그러므로 위를 일반화하면 $n$조각 퍼즐에 대하여 그 모든 단계마다 연역될 경우는 $n!$이고 그것의 무작위성은 $\log_{n}{n!}=L$으로 약속된다. 이에 대하여 그 발생확률은 아래와 같다.
          </p>

          <div class="math-display">
            $$\frac{1}{n!^L}$$
          </div>

          <p class="left-align-text">
            아래에 한가지 주의할 사항을 작성해 둔다. 슬라이딩퍼즐게임 논문의 정리 3.1(랜덤랜덤 정리의 증명)의 아래 계산은 로그의 밑으로 일반적인 $n$을 취해서 계산했다는 것을 잊지 말아야 할 것이다.
          </p>

          <div class="math-display">
            $$0=\log\frac{n}{n} = \log n - \log n = -\log \frac{1}{n} + \log \frac{1}{n} =\mathcal{I}(1) -\mathcal{I}(1)^{c}$$
          </div>

          <p class="left-align-text">
            즉, 다시말해서 로그의 밑으로 슬라이딩 퍼즐의 조각 갯수 $k$를 잡고, 그때 $n=k!$으로 잡아도 위 무작위성의 계산의 결과에 영향을 만들지 않는다. 즉, 위의 계산은 일반화 되어 있다는 것을 알 수 있다. 이것으로 랜덤랜덤 정리 증명의 보충설명을 마친다.
          </p>

          <h3>3.2 Conclusion: Entropy</h3>
          <p class="left-align-text">
            정보이론의 엔트로피의 정의 또한 마찬가지 의미를 가지고 계산된다. 그것은 무작위성이 발생할 확률을 곱해주어서 정보의 양을 적절하게 구하고 그것을 모두 합한다. 그때 그러한 계산은 위의 (2)의 수식계산의 정의와 일치한다. 정보이론의 엔트로피의 정의는 아래와 같다.
          </p>

          <div class="math-display">
            $$\sum_1^n p(x) \log\frac{1}{p(x)}$$
          </div>

          <p class="left-align-text">
            우리는 이때 선택 2의 비직관 알고리즘에 대하여 위의 엔트로피를 다시 표현해야 한다. 우선 확률 $P(x)$는 발생하지 않는다. 그리고 우리는 우리가 계산한 첫번째 선택 1의 엔트로피는 발생하지 않도록 해야 하므로 그러한 무작위성은 뺄셈 되어야 한다. 그것이 선택 2이다. 그러므로 아래가 성립한다.
          </p>

          <div class="math-display">
            $$\sum_1^n p(x)^{c} \log\left( \frac{1}{p(x)} \right) - \sum_1^n p(x) \log\left( \frac{1}{p(x)} \right)$$
          </div>

          <p class="left-align-text">
            이때 임의의 단계에서 확률적 표현은 단 하나로 약속되므로 시그마 기호 $\sum$는 의미가 없다. 엔트로피 수식을 사용하여 계산될때 무작위성 정보의 양은 $S_i - S_{i-1}$로 계산된다. 왜냐하면 그러한 차이가 임의의 단계에서 발생하는 무작위성의 양이기 때문이다.
          </p>

          <div class="math-display">
            $$\log \frac{1}{p(x)}(1-p(x)+p(x))=\log \frac{1}{p(x)}$$
          </div>

          <p class="left-align-text">
            정리 3.1의 수식 (2)를 다시 계산해 보기로 한다. 주어진 $k$개의 조각을 가지는 슬라이딩 퍼즐에 대하여 두개의 단계 $S_{i-1}, S_{i}$가 함께 나타난다. 왜냐하면 슬라이딩퍼즐게임의 확률적 계산이란 그 전단계의 주어진 슬라이딩 퍼즐의 구조를 보고 의사결정자가 여러 조합의 시도 후 그 후단계의 무작위성을 결정한다. 그런데 정보이론의 엔트로피 계산은 정보의 양에 그 발생확률을 대수적으로 곱해준다. 그런데 그러한 확률의 곱셈은 단 하나의 단계에 대한 정보의 양이다. 그러므로 그 후단계 $S_i$에서 그 전단계 $S_{i-1}$의 대수적인 뺄셈을 정의해 주어야 임의의 단계 $S$에서 발생하는 무작위성의 정보의 양을 계산 가능하다. 슬라이딩퍼즐에서 그것은 두 연역되는 임의의 단계에 대하여 간단히 대수적인 차이로 계산된다. 계산하여 정리하면 아래와 같다.
          </p>

          <div class="math-display">
            $$\sum_1^n \left( \frac{1}{k!} \right)^c \log_k k! + \sum_1^n \left( \frac{1}{k!} \right) \log_k k! - \sum_1^n \left( \frac{1}{k!} \right)^c \log_k k! - \sum_1^n \left( \frac{1}{k!} \right) \log_k k!$$
          </div>

          <div class="math-display">
            $$\log_k k! \left(1-\frac{1}{k!}+\frac{1}{k!}\right) - \log_k k! \left(1-\frac{1}{k!}+\frac{1}{k!}\right)$$
          </div>

          <div class="math-display">
            $$\log_k k! - \log_k k!=0$$
          </div>

          <p class="left-align-text">
            위와 같이 수식 (2)의 계산이 성립하고, 그것과 동일하다. 또한 정리 3.1이 참으로 확인된다. 이에 반하여 선택 1의 정보의 양은 그 전단계에 대하여 그 후 단계의 무작위성의 차이는 다음과 같이 계산된다.
          </p>

          <div class="math-display">
            $$-2\left( \frac{1}{k!} \right) \log_k k! +\left( \frac{1}{k!} \right) \log_k k! = -\left( \frac{1}{k!} \right) \log_k k!$$
          </div>

          <p class="left-align-text">
            선택 1은 무작위적인 선택이다. 그것은 항상 확률적 가능성의 아래에 있고 따라서 그 전단계에 대하여 그 후단계는 그러한 확률적 경우의 수는 $k!^2$이 발생하고 그것의 확률은 한단계에 대하여 발생하므로 확률은 $1/k!$이다.
          </p>

          <div class="math-display">
            $$-\left( \frac{1}{k!} \right) \log_k k!$$
          </div>

          <p class="left-align-text">
            임의의 단계에서 무작위성은 위와 같이 발생한다. 이에 반하여 선택 2는 대수적으로 매단계 위의 정보의 양으로 계산되는 무작위성을 뺄셈해준다. 따라서 그 후 단계에서 경우의 수의 누적이 대수적으로 발생하지 않는다.
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>4. Appendix I: Definition of the randomness 1, 2</h2>
          <p class="left-align-text">
            아래의 수식 (13)을 생각해보자. 그것은 슬라이딩퍼즐의 임의의 단계에서의 선택을 의미하며 $a,...z$으로 표현된다. 첨자 $i$ 는 참 또는 거짓이다. 즉, 슬라이딩퍼즐의 조합의 선택이 참 또는 거짓인 것을 의미한다. 그리고 첨수의 첨자 $p$는 각각 슬라이딩 퍼즐의 단계에서의 절대확률을 의미한다. 그때 그것은 선택공리와 동치이다.
          </p>

          <div class="math-display">
            $$\bigcup_{ a \thicksim z} a_{(i)_{p}}$$
          </div>

          <p class="left-align-text">
            예전 처음 작성했던 슬라이딩 퍼즐공간 문서에서는 그 랜덤워크(간단히 무작위성 $n$라고 부르기로 한다.)로 슬라이딩 퍼즐을 풀이할때 경기자 자신의 선택을 제외할때 또 다른 무작위성이 발생한다고 주장하였다. 슬라이딩 퍼즐을 풀이하는 경기자를 가정한다는 것이 선택공리를 가정한다는 것과 동치라는 설명을 슬라이딩 퍼즐 게임 1에서 작성한 적이 있다.<sup>처음 슬라이딩퍼즐게임 논문은 경제학의 게임이론의 공통지식을 사용하여 작성 하였다. 그러나 그러한 ``경제학의 이론이 수학인가?''에 대한 대답이 명확하지 않았고 따라서 그러한 슬라이딩 퍼즐게임에서 발생하는 무작위적 특성을 추출하여 수학적으로 추상화 하였다. 그러한 특성을 증명한 것이 정리 1이다. 그리고 또한 이때 발생하는 무작위성 1, 2의 엄밀한 수학적 정의를 위하여 선택공리를 사용하였다. 그러나 이 부분 또한 논란의 여지가 있을수 있다고 생각했으므로 선택공리를 또한 추가로 증명하였다. 독자들은 선택공리에 대하여 전문적인 지식이 필요하지는 않을 것이라고 예상한다. 단지 이 논문에 소개된 내용들만 알아도 충분 할 것이라고 예상한다.</sup> 기본개념은 간단하다. 슬라이딩 퍼즐의 조각마다 서로 다른 색칠을하고 그것을 움직이는 것을 하나의 항아리에서 그 퍼즐색상의 공을 꺼내는 것으로 대응 시키면 간단하다. 그렇다면 그러한 선택공리는 또한 확률적 표현으로 미래에 발생할 일로 정의 가능하다는 것도 노트에 작성한 적이 있다. 즉, 우리는 미래에 일어날 일을 누구도 예측할수 없다. 그럼 이때 자신의 선택을 발생하지 않게 해보자. 그것은 또한 미래시간의 흐름인 확률적 사건에 대하여 그것을 선택하지 않을 것이라는 것이다. 즉, 어떤 예측도 불 가능하다. 무작위성 1은 미래형 선택공리에 의하여 성립한다. 즉, 그것은 미래의 사건으로 간주할수 있고 우리는 미래에 일어날 일을 현실에서 증명해 낼수는 없으므로 무작위성 1이 항상 발생한다. 이에 대하여 선택 1을 따르지 않을때 우리는 어떠한 미래의 선택도 하지 않는 것이 된다. 그것은 어떠한 예측도 불 가능하다. 왜냐하면 어떤 미래의 확률적 사건에도 포함되지 않기 때문이다.
          </p>

          <p class="left-align-text">
            선택공리는 다음과 같은 주장을 하고 있다. 비어있지 않은 `서로소인 집합족에서 각각 하나씩의 원소를 뽑아서 새로운 집합을 구성하는게 가능하다.' 그런데 우리는 이때 칸토어의 집합의 기본 정의를 생각해보자. 그것은 간단하게 다른 것들과 직관적으로 구분 되어야 한다. 우리는 슬라이딩 퍼즐게임에서 서로소인 집합족을 구성하는 것은 간단하다. 각각의 슬라이딩 퍼즐게임의 구조를 색상으로 또는 처음 처럼 숫자로 대응시키고 집합족 항아리 마다 그것을 이름으로 지정하면 모두 그것은 서로소이다. 왜냐하면 그것은 각각의 슬라이딩 퍼즐의 단계마다 서로 다른 항아리 이름에 대하여 다른 방향을 가지기 때문이다. 그럼 이때 들어나는 문제는 명확하다. 우리는 항아리마다 세개의 공이 있지만 결국은 하나의 공을 꺼낸다. 그럼 결국은 하나의 공을 꺼내므로 그것으로 집합을 구축 가능하다는 것은 결국 다른 두가지 공을 꺼내는 방법 더 나아가서 슬라이딩 퍼즐이 만드는 모든 조합을 직관적으로 구분 가능하다라는 것을 가정하는 것과 동치가 된다. 선택공리를 가정한다는 것은 그런 의미를 가진다. 우리가 슬라이딩 퍼즐 공간 문서에서 가정하는 것은 선택공리가 아니다. 우리는 게임이론의 경기자 가정이 각각의 슬라이딩 퍼즐 항아리에서 공을 뽑을수 있다는 것 까지의 의미만을 가정한다.? 그러므로 결국 선택공리를 가정하는 것은 아니다. 결국 슬라이딩 퍼즐이 최단거리로 풀이되면 그것은 모든 슬라이딩 퍼즐조합과 구분된다. 즉, 하나의 집합을 구성한다. 이것이 의미하는 결과는 누구나 쉽게 알수 있으리라 믿는다.
          </p>

          <p class="italic-text left-align-text">The Choice-Function Principle에 의하면 집합 항아리에서 공을 뽑는 것이 가능하다는 가정하는 것만으로 선택공리와 동치이다. 다음장에 소개될 미래확률로 나타나는 선택공리에서 그 첨자는 참과 거짓을 의미한다.(즉, 선택함수의 참 값과 같이 언제나 $a$를 뽑고자 하면 그것이 뽑히는 것은 아닌 상태이다. 왜냐하면 거짓을 뽑았을때 그것은 최단거리 조합이 아니고 그것은 여타의 다른 것들과 구분되지 않는다. 즉, 그것은 결국은 처음 선택공리 버전을 적용할때 집합으로의 구성도 불 가능하다. 그러므로 거짓을 뽑는 사건은 뽑지 못한것과 동일하다.) 그리고 슬라이딩 퍼즐게임의 임의의 단계에서의 $3$가지의 선택이 확률로서 존재한다. 그때 참인것을 뽑는 사건을 $A$라고 할 수 있다. 즉 첨자는 참, 거짓으로 작성된다. 즉, 선택공리와 같이 선택함수 $f(a) \in a$(함수는 선택함수이다.)와 같이 언제나 참인것을 뽑는 상태를 가정하지 않는다. 즉, 슬라이딩 퍼즐에서 사용하는 미래확률형 선택공리는 문제화(<em class="italic-text">mathematical problem</em>) 되어 있다. 즉, 그것은 특정 알고리즘 없이 선택공리와 동치가 아니다. 왜냐하면 집합 항아리에서 어떤 특정 $a$를 뽑는 것이 가능하다는 가정은 그것을 뽑을때 참인것을 의미한다. 그런데 우리는 그것을 뽑을 선택함수를 첨수의 첨자인 확률로 정의한다. 즉, 그것은 가능할수도 또는 그렇지 않을수도 있는 상태에 있다.(선택공리의 참 가정은 언제나 그러한 원소하나를 뽑을수 있다고 가정한다. 그러나 우리는 그것을 뽑을수 없을수도 없다고 가정하며, ``즉 선택공리는 거짓일수도 있다.'' 그러한 장치로 3개의 공과 참, 거짓 그리고 확률적 상황을 추가한 것이다.) 이러한 개념은 선택공리가 마치 수학의 문제와 같이 질문 형태로 바뀐 것을 알수 있다. 그때 그것은 ``슬라이딩 퍼즐 위에서 선택공리는 참인가?'' 묻고 있다. 그럼 답은 비직관 알고리즘을 적용한다는 조건 아래서만 참이다. 우리는 이때 이 논문에서 이야기 하는 선택 $1$의 무작위성을 쉽게 이해할수 있다. 충분히 큰 슬라이딩 퍼즐에 대하여 우리는 슈퍼 콤퓨터는 아니므로 그 해답을 알수 없다. 즉, 항상 슬라이딩 퍼즐 집합 항아리에서 원하는 것을 뽑을수 없고, 그것은 조합적 확률로 주어진다. 즉, 그것은 항아리에서 아무 공이나 마구 꺼내어서 나열하는 것과 동치이다. 그것은 무작위성을 가지고 이것이 무작위성 $1$이다. </p>
          <p class="left-align-text">
            위에 의하여 우리는 슬라이딩 퍼즐의 각각의 다른 숫자 구조마다의 퍼즐단계를 간단하게 하나의 색상으로 대응 시키자. 그리고 이때 우리가 그 단계 $S_i$에서 퍼즐의 올바른 방향을 선택했다면 우리는 그 퍼즐구조의 색상을 뽑은 것으로 약속하자. 그럼 이때 선택 1은 우리가 퍼즐의 올바른 방향을 알지 못하고 뽑는 것이다. 그때 우리는 어떤 색상의 공을 뽑는지도 알수없다. 따라서 그것은 결국 서로 다른 퍼즐의 풀이 단계에서 반드시 동일한 색상의 공이 뽑힐 가능성이 항상 존재한다. 그러므로 그러한 시도로는 어떤 공이 뽑힐지 알수 없고 따라서 그것이 무작위성 1의 정식 정의이다.(그러므로 당연히 선택공리에서 이야기하는 새로운 집합도 구축 불 가능하다.) 이에 반하여 그러한 선택1 제외한 확률적 가능성인 선택 2를 발생시킬때, 무작위성 1이 사라진다는 것을 랜덤랜덤정리에서 증명해 보였다. 즉. 확률적결과의 자리에 발생하는 새로운 확률적가능성이 무작위성 2이다.
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>5. Appendix II: Choice axiom</h2>
          <p class="left-align-text">
            쌍으로 독립인 시그마대수(<em class="italic-text">mutually P-independence</em>)를 생각해보자. 우리는 각각의 첨자 $i$를 사건이 일어나거나 또는 일어나지 않거나로 간주하기로 한다. 그리고 첨자의 인덱스는 각각의 확률적 사건이 나타내는 첨자이다. 단순하게 예제를 만들어서 설명해보자. 우리는 임의로 일곱가지 빨, 주, 노, 초, 파, 남, 보라색을 가진 몇십개의 3, 4, 5, 6각형 주사위를 가지고 있다. 그때 첫번째 첨자 $i$는 빨강색에 대하여 작동한다고 하고 이때 5의 눈이 나올 확률을 나타내는 것은 $i$의 첨자 $m$이다. 정의는 당연하므로 넘어가고 이러한 확률의 독립시행이 선택공리와 동일한 것은 당연하다. 앞의 핵심은 다음과 같다. 선택공리가 확률공간에서 현재에 대하여 미래에 일어날 사건으로 표현 가능하다는 것이다. ``이것이 무슨 의미일까?'', 선택공리는 우리가 각각이 서로 다른 색상의 항아리 안에서 서로 다른 색상의 공을 뽑아서 새로운 집합을 구성하는 것이 가능하다라는 주장을 하고 있다. 그러나 이러한 사건은 바로 위 단락의 주사위 사건과 대응된다. 즉, 그것은 현재에 대하여 항상 미래에 일어날 사건이다. 그러므로 선택공리의 증명 가능성이 주장하는 것은 미래의 확률적 사건이 발생한다는 것을 현재에서 증명 하라는 것이다. 간단히 이것은 시간적 흐름 아래에서 불 가능하다. 왜냐하면 우리는 항상 현재를 살아가기 때문이다. 따라서 앞장의 비직관적 알고리즘을 사용하여 다음장에서 확률적 사건을 다시 정의하기로 한다.
          </p>
        </section>

        ---

        <section class="section-block">
          <h2>6. Appendix III: Proof of Choice axiom</h2>
          <p class="left-align-text">
            이 논문의 비직관적 알고리즘은 간략하게 요약하면 처음 슬라이딩 퍼즐을 풀이하는 경기자의 계산능력으로 만들어진 첫번째 선택 1을 제외하고, 나머지 2개의 슬라이딩 퍼즐 방향중 어떤 것이든 선택을 한다. 그것을 선택 2라고 이야기 하고 있다. 그런데 그것은 확률적 가능성을 발생 시키는 절차와 동일하다. 우리는 다음과 같이 약속하기로 한다. 확률적 가능성을 $P(reason):=P(r)$ 그리고 확률적 결과는 $P(conclusion):=P(c)$라고 표기하기로 한다. 예를들어서 주사위의 확률적 가능성은 6가지이고 그 결과는 공중에 던져져서 떨어졌을때를 의미한다.
          </p>

          <p class="left-align-text">
            3장의 슬라이딩 퍼즐게임의 무작위성으로 추상화된 랜덤랜덤정리(정리 3.1)의 증명이 수학적으로 불 충분하다고 느끼시던 분들은 이번 선택공리 증명에는 만족할 것이라고 느낀다. 랜덤랜덤정리 증명은 선택공리의 참을 가정해야 했다.?(가정이 아닌 논란의 여지가 있다고 생각한다. 논란의 여지가 있다는 것은 명확하지 않을수도 있다는 의미이다.) 그러므로 이장에서는 선택공리를 증명하기로 한다. 5장에 의하여 선택공리는 확률변수를 가지도록 표현하고 나타내는 것 또한 가능하다. 이때 우리는 앞장에 의하여 미래를 증명해야 하는 어처구니 없는 경우를 맞닥뜨리게 된다. 그런데 슬라이딩 퍼즐게임의 비직관 알고리듬은 확률적 인과관계가 서로 반대이다. 즉, 우리는 확률적 가능성 $P(r)$을 결과의 자리에 발생 시킴으로 시간의 수학적 흐름을 반대로 정의 하는 것이 가능하다. 그때 미래는 과거로, 과거는 미래로 간주하는 것이 가능하다. 즉, 선택공리는 해결가능하다
          </p>

          <p class="left-align-text">
            우리는 위와 같은 개념을 그래프 이론의 트리(<em class="italic-text">tree</em>) 위에서 생각해 보자. 당연히 트리형 그라프의 $n$개의 서로 다른 색상의 정점에 대하여 연역적으로 하나의 정점만을 선택해 나갈때 우리는 간선으로 연결된 다음 선택에서 같은 정점의 색상을 다시 선택하면 안된다. 왜냐하면 그때 새로운 집합이 구성되지 않기 때문이다. 그럼 우리는 위와 같은 경우에 대우식 알고리듬을 적용해보자. 즉, 우리는 정방향에서 아닌것을 제외하고 확률적 선택을 한다. 그럼 그것의 역방향 확률해석은 어떻게 될까? 처음 확률이 약속될때 발생하는 확률이 아닌 발생하지 않는 확률이 정의된다. 즉, 확률변수는 발생 가능한 확률로도 정의 가능하지만 발생하지 않는 확률로도 정의 가능하다.(기존 확률의 정의와 다르다. 발생 가능하지 않은 확률을 기존 확률변수 정의에서는 확률적 가능성 아래에서 확인 불 가능하다. 즉, 다시말해서 발생해야만 확인 가능한 것이 아니다. 비-직관 알고리즘을 적용한 경우 우리는 선택 1을 제외하고, 선택 2를 만들어낸다는 것은 확률적 결과 $P(c)$가 발생할 위치에 확률적 가능성 $P(r)$을 발생 시키는 것이다. 그러므로 시간의 역방향으로 그것을 다시 해석해 볼때 발생하지 않을 확률이 확률적 가능성 $P'(r)$으로 새롭게 정의된다.) 우리는 이때 선택공리가 증명된다는 것을 쉽게 확인 가능하다. 즉, 모든 트리 위의 정점마다 아닌 것을 제외하고 서로 다른 정점을 선택하는 것이 가능하다. 다음은 위의 논의에서 사용한 트리 그래프의 처음 상태의 그림을 보여주고 있다. 처음 $n$개의 서로 다른 정점의 집합족이 존재한다.(설명의 편의를 위하여 처음 서로소인 제한 조건을 적용하지 않았다.)
          </p>

          <p class="left-align-text">
            위의 정점들은 분명 선택공리에서 이야기하는 그 항아리와 대응된다는 것은 누구도 쉽게 알수 있을 것이다. 우리는 그 전 단계에서 빨강을 뽑았다고 가정하자. 그럼 그 다음 단계에서 빨강을 제외하고 어떤 것이든 확률적 선택을 하면 된다. 그것을 주황이었다고 가정해보자.,... 그러한 절차는 반복된다. 그럼 우리는 그때 매절차마다 하나의 가능성 트리가 만들어진다는 것을 알 수 있다. 즉, 첫번째 빨강을 제외했으므로 간선은 빨강에서 부터 다음 단계의 정점들로 내려와서 연결된다.(단, 빨강은 제외이다.) 그 두번째 절차에서 빨강을 제외하고 어떤 것이든지 선택할 수 있다. 즉, 그 전 단계 선택한 빨강으로 부터 다음 단계의 선택의 확률적 가능성은 트리로 표현 가능하다. 그러한 트리가 매절차마다 만들어 진다. 우리는 그때 그러한 가능성 트리를 반대로 생각해 보자. 그럼 마지막 검정정점이 남아있었다고 가정하면 그 단계에서는 빨강, 주황, 노랑, 초록, 파랑, 남색, 보라, ..., $n-1$까지 색상의 확률적 가능성은 발생하지 않는다. 왜냐하면 우리는 정방향 단계에서 그것은 $n$단계에서 발생하지 않는 확률적사건으로 약속했기 때문이다. 즉, 다시말해서 반대 방향 확률적 가능성 $P'(r)$은 발생하지 않는 확률을 정의하고 있다. 그러한 발생하지 않는 확률은 정방향 트리 그라프의 외부에 존재하게 정의된다는 것도 쉽게 상상할 수 있다. 가능성 트리그래프가 첫단계 $S_1$에서 아래와 같이 나타날때, 반대로 확률적 해석했을때 발생하지 않는 확률은 아래와 같이 나타난다. 단 확률적 가능성을 정의하는 선택이 정점색깔 순서대로 나타났다고 약속한다.
          </p>

          <p class="left-align-text">
            논문의 증명을 읽을때 주의해야 할 사항들이 있다. 우리는 정리 3.1에 대하여 그 증명을 3.1에 소개된 정보이론의 정보의 양 정의를 사용한 증명으로 볼때는 선택공리의 증명이 필요할수도 있다. 그러나 정리 3.1에 대하여 그 무작위성의 정의를 선택공리로 정의하고 그 증명을 선택공리증명으로만도 이해할 수 있다. 또한 정리 3.1의 증명은 그러므로 슬라이딩퍼즐의 최단거리 풀이 그리고 유한한 선택공리를 동시에 증명하고 있다고도 볼 수 있다.
          </p>
        </section>
      </div>
    </main>

    <footer class="bottom-menu">
      <nav>
        <ul>
          <li><a href="#">개인정보처리방침</a></li>
          <li><a href="#">이용약관</a></li>
          <li><a href="#">사이트맵</a></li>
          <li><a href="#">고객센터</a></li>
        </ul>
      </nav>
      <p>&copy; 2025 Smilenumber group. All rights reserved.</p>
    </footer>
  </div>
</template>

<script>
export default {
  name: 'CarSales',
  mounted() {
    // MathJax 또는 KaTeX 로드 및 렌더링 로직 (프로젝트 설정에 따라 다름)
    // window.MathJax가 존재하는지 확인하여 'forEach' 오류 방지
    if (window.MathJax) {
      window.MathJax.typesetPromise(); // 페이지의 모든 LaTeX 수식을 렌더링
    }
  }
};
</script>

<style scoped>
/* 페이지 전체 컨테이너 */
.page-container {
  display: flex;
  flex-direction: column;
  min-height: 100vh; /* 뷰포트 높이 전체를 차지 */
  font-family: 'Malgun Gothic', 'Apple SD Gothic Neo', sans-serif; /* 한글 폰트 적용 */
  line-height: 1.6;
  color: #333;
}

/* 상단 메뉴 스타일 */
.main-menu, .bottom-menu {
  background-color: #f8f8f8;
  padding: 15px 20px;
  border-bottom: 1px solid #eee;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.main-menu ul, .bottom-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  justify-content: center;
  gap: 25px; /* 메뉴 항목 간 간격 */
}

.main-menu a, .bottom-menu a {
  text-decoration: none;
  color: #333;
  font-weight: bold;
  padding: 5px 10px;
  transition: color 0.3s ease;
}

.main-menu a:hover, .bottom-menu a:hover {
  color: #007bff;
}

/* 주요 내용 영역 */
.main-content {
  flex-grow: 1; /* 남은 공간을 모두 차지하여 바닥글을 하단으로 푸시 */
  padding: 30px 20px;
  max-width: 900px; /* 논문 내용의 최대 너비 제한 */
  margin: 0 auto; /* 내용을 중앙 정렬 */
  width: 100%; /* 너비 100% 사용 (max-width가 적용됨) */
  box-sizing: border-box; /* 패딩 포함 너비 계산 */
}

.math-article h1, .math-article h2 {
  text-align: left; /* 제목도 좌측 정렬로 변경 */
  color: #2c3e50;
  margin-top: 40px;
  margin-bottom: 20px;
}

.math-article h1 {
  font-size: 2.5em;
  border-bottom: 2px solid #eee;
  padding-bottom: 10px;
}

.math-article h2 {
  font-size: 1.8em;
  margin-bottom: 15px;
}

/* 제목, 저자, 주소, 이메일, 키워드 등 스타일 */
.title {
  font-size: 2.2em;
  margin-top: 0;
  margin-bottom: 10px;
}

.author, .address, .email, .acknowledgement, .keywords {
  text-align: left; /* 이 부분들도 좌측 정렬 */
}

.author {
  font-size: 1.1em;
  margin-bottom: 5px;
}

.address, .email {
  font-size: 0.9em;
  color: #555;
  margin-bottom: 3px;
}

.acknowledgement, .keywords {
  font-size: 0.8em;
  color: #777;
  margin-top: 10px;
}

/* 본문 텍스트 좌측 정렬 및 단락 스타일 */
.left-align-text {
  text-align: left;
  margin-bottom: 1em; /* 단락 아래 간격 */
  font-size: 1.05em;
}

/* 수식 표시 영역 */
.math-display {
  text-align: center; /* 수식은 중앙 정렬 유지 */
  margin: 25px 0; /* 위아래 여백 */
  font-size: 1.15em; /* 수식 글꼴 크기 */
  overflow-x: auto; /* 긴 수식 스크롤 가능 */
}

/* 테이블 컨테이너 (퍼즐 게임 표) */
.table-container {
  margin: 30px auto;
  text-align: left; /* 테이블 컨테이너 안의 텍스트도 좌측 정렬 */
  max-width: fit-content; /* 표 내용에 맞게 너비 조절 */
}

.table-container h3 {
  margin-bottom: 10px;
  font-size: 1.2em;
  text-align: left; /* 테이블 제목도 좌측 정렬 */
}

.table-container table {
  border-collapse: collapse;
  margin: 0; /* 테이블 자체는 중앙 정렬하지 않고 left-align-text의 흐름을 따름 */
  border: 1px solid #ccc;
}

.table-container th, .table-container td {
  border: 1px solid #ccc;
  padding: 10px 15px;
  text-align: center; /* 테이블 셀 안의 내용은 그대로 중앙 정렬 유지 */
}

.table-container th {
  background-color: #f2f2f2;
}

/* Figure Caption 삭제에 따라 이 스타일도 제거 */
/* .figure-caption {
  font-size: 0.9em;
  color: #666;
  margin-top: 10px;
  text-align: center;
} */

/* 각 섹션 블록 간 구분선 */
.section-block {
  margin-bottom: 50px;
}

/* 바닥글 스타일 */
.bottom-menu {
  border-top: 1px solid #eee;
  margin-top: 40px;
  text-align: center;
  color: #666;
  font-size: 0.9em;
  padding-top: 20px;
  padding-bottom: 20px;
}

.bottom-menu p {
  margin-top: 15px;
}

/* 이탤릭 텍스트 */
.italic-text {
  font-style: italic;
}

/* 각주(footnote) 스타일 */
sup {
  font-size: 0.7em;
  vertical-align: super;
  line-height: 0;
  margin-left: 2px;
}

/* 각주가 있는 단락의 들여쓰기 */
.left-align-text sup + span.footnote-content {
  display: block; /* 각주 내용을 새 줄에서 시작 */
  text-indent: -1.5em; /* 들여쓰기 조절 (숫자에 맞게) */
  margin-left: 1.5em; /* 왼쪽 여백 */
  font-size: 0.9em; /* 각주 텍스트 크기 */
  color: #777; /* 각주 텍스트 색상 */
}

/* 기존 sup + p rule 제거. 필요시 직접 각주 내용 감싸기 */
/* sup + p {
  text-indent: -1.5em;
  margin-left: 1.5em;
} */
</style>